<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>time/sloth</title>

  <style>
    :root{
      --scale: 1.15;
      --bg: #1b1b1b;
      --fg: #ffffff;
      --card: rgba(0,0,0,.18);
      --btn: rgba(255,255,255,.14);
      --btn2: rgba(255,255,255,.22);
      --outline: rgba(255,255,255,.22);

      --stageFg: #ffffff;
      --stageBadgeBg: rgba(0,0,0,.22);
      --stageBadgeBorder: rgba(0,0,0,.18);
      --laneBg: rgba(0,0,0,.18);
      --trackShadow: rgba(0,0,0,.25);
    }

    *{ box-sizing: border-box; }
    html,body{
      height:100%;
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: calc(16px * var(--scale));
    }
    body{
      background: var(--bg);
      color: var(--fg);
      overflow:auto;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    body.run{ overflow:hidden; }

    .wrap{
      height:100%;
      padding: 14px;
      padding-top: calc(14px + env(safe-area-inset-top));
      padding-bottom: calc(14px + env(safe-area-inset-bottom));
      display:flex;
      flex-direction:column;
      gap: 12px;
      overflow-y:auto;
      -webkit-overflow-scrolling: touch;
    }

    .topbar{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
    }
    .title{
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight:900;
      letter-spacing:.2px;
      font-size: calc(16px * var(--scale));
      opacity:.95;
    }
    .logoTop{
      height: 26px;
      width: 26px;
      display:block;
      opacity: .9;
    }

    .panel{
      background: var(--card);
      border: 1px solid var(--outline);
      border-radius: 16px;
      padding: 12px;
    }
    .row{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items:center;
    }
    .small{ font-size: calc(12px * var(--scale)); opacity:.82; font-weight:800; }
    .toast{ margin-top: 6px; font-size: calc(12px * var(--scale)); opacity: .95; min-height: 16px; font-weight:800; }
    .hint{ font-size: calc(12px * var(--scale)); opacity: .8; font-weight:800; }

    .grid{ display:grid; gap: 10px; }
    .grid.cols2{ grid-template-columns: 1fr 1fr; }

    .chip{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 8px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 12px 12px;
      min-height: 52px;
    }
    .chip label{ display:flex; align-items:center; gap:10px; width:100%; cursor:pointer; font-weight:900; }
    .chip input[type="checkbox"]{ transform: scale(1.25); }

    .dot{
      width: 14px; height: 14px; border-radius: 50%;
      border: 1px solid rgba(0,0,0,.25);
      flex: 0 0 auto;
    }

    button{
      font: inherit;
      border: 1px solid rgba(255,255,255,.18);
      background: var(--btn);
      color: var(--fg);
      border-radius: 16px;
      padding: 14px 12px;
      font-weight: 900;
      cursor:pointer;
      min-height: 54px;
    }
    button:active{ transform: translateY(1px); }
    button.primary{ background: var(--btn2); border-color: rgba(255,255,255,.28); }
    button.danger{ background: rgba(255,60,60,.22); border-color: rgba(255,60,60,.35); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }

    .btnrow{ display:grid; gap: 10px; }
    .btnrow.controls{ grid-template-columns: 1fr 1fr; }
    .btnrow.times{ grid-template-columns: 1fr 1fr 1fr; }

    /* Stage */
    .stage{
      flex: 1 1 auto;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      border-radius: 22px;
      border: 1px solid rgba(0,0,0,.25);
      background: rgba(0,0,0,.15);
      padding: 18px;
      text-align:center;
      gap: 10px;
      position: relative;
      overflow:hidden;
      isolation: isolate;
      min-height: 240px;
    }

    .stageLogo{
      position:absolute;
      top: 12px;
      left: 12px;
      height: 26px;
      width: 26px;
      z-index: 5;
      pointer-events:none;
      opacity: .9;
    }

    .badge{
      position:absolute;
      top: 10px;
      right: 10px;
      background: var(--stageBadgeBg);
      border: 1px solid var(--stageBadgeBorder);
      color: var(--stageFg);
      border-radius: 999px;
      padding: 8px 10px;
      font-weight: 900;
      font-size: calc(12px * var(--scale));
      letter-spacing: .3px;
      z-index: 3;
    }

    .mode{
      color: var(--stageFg);
      font-size: clamp(34px, 7vw, 56px);
      font-weight: 900;
      letter-spacing: .6px;
      line-height: 1.05;
      z-index: 2;
    }
    .time{
      color: var(--stageFg);
      font-size: clamp(56px, 11vw, 92px);
      font-weight: 900;
      letter-spacing: 1px;
      line-height: 1;
      z-index: 2;
    }
    .next{
      color: var(--stageFg);
      margin-top: clamp(10px, 3vh, 22px);
      font-size: clamp(18px, 3.6vw, 26px);
      font-weight: 900;
      opacity: .98;
      letter-spacing: .4px;
      font-style: italic;
      z-index: 2;
    }
    .sub{
      color: var(--stageFg);
      font-size: calc(13px * var(--scale));
      opacity: .9;
      line-height: 1.35;
      z-index: 2;
      font-weight: 800;
    }

    .blinkMode{ animation: blink 0.85s step-end infinite; }
    .blinkTime{ animation: blink 0.85s step-end infinite; }
    @keyframes blink{ 50%{ opacity: .15; } }

    /* Splash */
    .splash{
      position:fixed;
      inset:0;
      background: #0f0f0f;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      gap: 14px;
      z-index: 999;
      opacity: 1;
      transition: opacity 420ms ease;
      padding: 18px;
      text-align:center;
    }
    .splash.hide{ opacity:0; pointer-events:none; }
    .splashLogo{ width: min(260px, 70vw); height:auto; display:block; opacity:.95; }
    .splashText{ font-weight: 900; letter-spacing: .6px; font-size: calc(22px * var(--scale)); opacity: .95; }
    .splashSub{ font-size: calc(13px * var(--scale)); opacity: .78; max-width: 46ch; line-height: 1.35; font-weight:800; }
    .splashBtn{ margin-top: 8px; width: min(360px, 92vw); }

    /* Run view */
    body.run .panel{ display:none; }
    body.run .wrap{ gap: 0; overflow: hidden; }
    body.run .topbar{ display:none; }
    body.run .stage{
      flex: 1 1 auto;
      border-radius: 22px;
      margin: 0;
      padding-top: calc(18px + env(safe-area-inset-top));
      padding-bottom: calc(18px + env(safe-area-inset-bottom));
    }

    .runControls{
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: calc(12px + env(safe-area-inset-bottom));
      display:none;
      z-index: 1000;
      gap: 10px;
    }
    body.run .runControls{
      display:grid;
      grid-template-columns: 1fr 1fr;
    }
    .runControls button{
      min-height: 58px;
      border-radius: 18px;
      font-size: calc(16px * var(--scale));
    }

    /* Track */
    .track{
      position:absolute;
      left: 14px;
      right: 14px;
      bottom: calc(100px + env(safe-area-inset-bottom));
      height: 28px;
      z-index: 4;
      display:flex;
      align-items:center;
      gap: 10px;
      pointer-events:none;
      opacity: .98;
    }
    .flag svg{
      color: var(--stageFg);
      filter: drop-shadow(0 1px 0 var(--trackShadow));
    }
    .lane{
      position: relative;
      flex: 1 1 auto;
      height: 8px;
      border-radius: 999px;
      background: var(--laneBg);
      overflow: visible;
    }
    .car{
      position:absolute;
      top: 50%;
      left: 0%;
      transform: translate(-50%, -50%);
      color: var(--stageFg);
      z-index: 2;
      will-change: left, transform, filter;
      filter: drop-shadow(0 2px 0 var(--trackShadow)) drop-shadow(0 0 10px rgba(255,255,255,.18));
    }
    .car.running{
      filter: drop-shadow(0 2px 0 var(--trackShadow)) drop-shadow(0 0 12px rgba(255,255,255,.25)) drop-shadow(0 0 22px rgba(255,255,255,.18));
    }
    .car.running .carSvg{
      transform-origin: 50% 70%;
      animation: wobble 260ms ease-in-out infinite;
    }
    @keyframes wobble{
      0%   { transform: rotate(-3deg) translateY(0px); }
      50%  { transform: rotate(3deg)  translateY(-1px); }
      100% { transform: rotate(-3deg) translateY(0px); }
    }
    .car.bounce{
      animation: bounce 520ms cubic-bezier(.2,.8,.2,1) 1;
    }
    @keyframes bounce{
      0%   { transform: translate(-50%,-50%) scale(1); }
      30%  { transform: translate(-50%,-70%) scale(1.06); }
      55%  { transform: translate(-50%,-45%) scale(.98); }
      75%  { transform: translate(-50%,-58%) scale(1.02); }
      100% { transform: translate(-50%,-50%) scale(1); }
    }
  </style>
</head>

<body>
  <div class="splash" id="splash">
    <img src="logo.png" class="splashLogo" alt="time/sloth logo">
    <div class="splashText">time/sloth</div>
    <div class="splashSub">Tap Enter to enable voice (important on Android) and start.</div>
    <button class="splashBtn primary" id="enterBtn">Enter</button>
  </div>

  <div class="runControls" id="runControls">
    <button id="skipRun">Skip</button>
    <button id="stopRun" class="danger">Stop</button>
  </div>

  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <img src="logo.png" alt="time/sloth logo" class="logoTop">
        <span>time/sloth</span>
      </div>
      <div class="small" id="status">Ready</div>
    </div>

    <div class="panel">
      <div class="row">
        <div class="small"><b>Groups</b></div>
        <div class="small">Time: <b id="intervalLabel">5 min</b></div>
      </div>

      <div class="grid cols2" style="margin-top:10px;" id="modeChecks"></div>

      <div class="btnrow times" style="margin-top:10px;">
        <button id="t2">2 min</button>
        <button id="t5" class="primary">5 min</button>
        <button id="t10">10 min</button>
      </div>

      <div class="btnrow controls" style="margin-top:10px;">
        <button id="start" class="primary">Start</button>
        <button id="stop" class="danger" disabled>Stop</button>
      </div>

      <div class="toast" id="toast"></div>
      <div class="hint">Välj minst en grupp.</div>
    </div>

    <div class="stage" id="stage">
      <img src="logo.png" class="stageLogo" alt="time/sloth logo">
      <div class="badge" id="badge">IDLE</div>

      <div class="mode" id="mode">Select groups</div>
      <div class="time" id="time">--:--</div>
      <div class="next" id="next">NEXT UP: --</div>
      <div class="sub" id="sub">Start to begin rotation</div>

      <div class="track" aria-hidden="true">
        <div class="flag" title="Start">
          <svg viewBox="0 0 24 24" width="22" height="22" aria-hidden="true">
            <path fill="currentColor" d="M6 2h2v20H6z"/>
            <path fill="currentColor" d="M8 3h10l-2 3 2 3H8z"/>
          </svg>
        </div>

        <div class="lane">
          <div class="car" id="car" title="Car">
            <svg class="carSvg" viewBox="0 0 64 32" width="28" height="14" aria-hidden="true">
              <path fill="currentColor"
                d="M10 22h44c3 0 5-2 5-5v-5c0-2-1-3-3-3h-7l-6-6H21l-6 6H8c-2 0-3 1-3 3v5c0 3 2 5 5 5z"/>
              <circle fill="currentColor" cx="20" cy="24" r="4"/>
              <circle fill="currentColor" cx="46" cy="24" r="4"/>
            </svg>
          </div>
        </div>

        <div class="flag" title="Finish">
          <svg viewBox="0 0 24 24" width="22" height="22" aria-hidden="true">
            <path fill="currentColor" d="M6 2h2v20H6z"/>
            <path fill="currentColor" d="M8 4h12v10H8z"/>
          </svg>
        </div>
      </div>
    </div>
  </div>

  <script>
    const el = (id) => document.getElementById(id);

    const splash = el("splash");
    const enterBtn = el("enterBtn");

    const stage = el("stage");
    const badge = el("badge");
    const statusEl = el("status");
    const toastEl = el("toast");

    const modeEl = el("mode");
    const timeEl = el("time");
    const nextEl = el("next");
    const subEl = el("sub");
    const carEl = el("car");

    const modeChecks = el("modeChecks");

    const intervalLabel = el("intervalLabel");
    const startBtn = el("start");
    const stopBtn  = el("stop");
    const stopRunBtn = el("stopRun");
    const skipRunBtn = el("skipRun");

    const t2 = el("t2");
    const t5 = el("t5");
    const t10 = el("t10");

    const MODE_KEYS = ["Group 1","Group 2","Group 3"];
    const LS_KEY = "ts_free_v2";

    const DEFAULT = () => ({
      durationMin: 5,
      enabled: { "Group 1": true, "Group 2": true, "Group 3": true }
    });

    let state = loadState();
    let intervalMin = clampInt(state.durationMin, 2, 10);
    let durationMs = intervalMin * 60 * 1000;

    let running = false;
    let rotation = [];
    let idx = 0;

    let slotStartedAt = 0;
    let slotEndsAt = 0;
    let tickTimer = null;

    let warned60 = false;
    let warned10 = false;
    let countdownTimer = null;

    // Wake Lock
    let wakeLock = null;
    async function requestWakeLock(){
      try{
        if (!("wakeLock" in navigator)) return;
        wakeLock = await navigator.wakeLock.request("screen");
      } catch(e){}
    }
    async function releaseWakeLock(){
      try{ if (wakeLock){ await wakeLock.release(); wakeLock = null; } } catch(e){}
    }
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible" && running) requestWakeLock();
    });

    function setToast(msg){ toastEl.textContent = msg || ""; }

    // ---------- TTS (queue, no overlap) ----------
    function pickEnglishVoice(){
      const voices = speechSynthesis.getVoices?.() || [];
      return voices.find(v => /en-US/i.test(v.lang)) ||
             voices.find(v => /en-GB/i.test(v.lang)) ||
             voices.find(v => /^en/i.test(v.lang)) || null;
    }

    let ttsChain = Promise.resolve();

    function speakQueued(text){
      if (!("speechSynthesis" in window)) return Promise.resolve();
      const msg = String(text || "").trim();
      if (!msg) return Promise.resolve();

      ttsChain = ttsChain.then(() => new Promise((resolve) => {
        try{
          const u = new SpeechSynthesisUtterance(msg);
          u.lang = "en-US";
          const v = pickEnglishVoice();
          if (v) u.voice = v;
          u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;

          u.onend = () => resolve();
          u.onerror = () => resolve();

          // Viktigt: avbryt inte hela världen varje gång, annars kolliderar det
          speechSynthesis.speak(u);
        } catch {
          resolve();
        }
      }));
      return ttsChain;
    }

    function cancelSpeech(){
      try{
        if ("speechSynthesis" in window) speechSynthesis.cancel();
      } catch(e){}
      ttsChain = Promise.resolve();
    }

    if ("speechSynthesis" in window && speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = () => pickEnglishVoice();
    }

    // ---------- utils ----------
    function fmtMMSS(ms){
      const total = Math.max(0, Math.ceil(ms / 1000));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return String(m).padStart(2,"0") + ":" + String(s).padStart(2,"0");
    }
    function clampInt(n, a, b){
      n = Number(n);
      if (!Number.isFinite(n)) n = a;
      return Math.max(a, Math.min(b, Math.round(n)));
    }
    function cssKey(k){
      return String(k).replaceAll("/","_").replaceAll(" ","_");
    }

    function loadState(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return DEFAULT();
        const p = JSON.parse(raw);
        if (!p) return DEFAULT();
        return { ...DEFAULT(), ...p, enabled: { ...DEFAULT().enabled, ...(p.enabled||{}) } };
      } catch {
        return DEFAULT();
      }
    }
    function saveState(){
      try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); } catch(e){}
    }

    function applyStageTheme(key){
      const colors = {
        "Group 1": ["#1e5aa8","#0b2f59"],
        "Group 2": ["#f08a1a","#8a4a00"],
        "Group 3": ["#2e7d32","#0f3b12"],
      };
      const [c1,c2] = colors[key] || ["#333","#111"];
      stage.style.background = `linear-gradient(90deg, ${c1} 0 50%, ${c2} 50% 100%)`;
      document.documentElement.style.setProperty("--stageFg", "#ffffff");
    }

    function setBlink(on){
      if (on){
        modeEl.classList.add("blinkMode");
        timeEl.classList.add("blinkTime");
      } else {
        modeEl.classList.remove("blinkMode");
        timeEl.classList.remove("blinkTime");
      }
    }

    function buildRotation(){
      const list = [];
      for (const k of MODE_KEYS){
        if (state.enabled[k]) list.push(k);
      }
      rotation = list;
      return rotation;
    }
    function getNextKey(){
      if (rotation.length === 0) return "--";
      if (rotation.length === 1) return rotation[0];
      return rotation[(idx + 1) % rotation.length];
    }

    function enterRunView(on){
      document.body.classList.toggle("run", !!on);
    }

    function setCarProgress(now){
      const elapsed = Math.max(0, Math.min(durationMs, now - slotStartedAt));
      const pct = (elapsed / durationMs) * 100;
      carEl.style.left = pct.toFixed(2) + "%";
    }
    function resetCar(){
      carEl.style.left = "0%";
      carEl.classList.remove("running");
      carEl.classList.remove("bounce");
    }
    function startCarEffects(){
      carEl.classList.add("running");
      carEl.classList.remove("bounce");
      void carEl.offsetWidth;
      carEl.classList.add("bounce");
      setTimeout(() => carEl.classList.remove("bounce"), 650);
    }
    function stopCarEffects(){
      carEl.classList.remove("running");
      carEl.classList.remove("bounce");
    }

    function lockInputs(lock){
      for (const k of MODE_KEYS){
        const cb = el("cb_" + cssKey(k));
        if (cb) cb.disabled = lock;
      }
      t2.disabled = lock;
      t5.disabled = lock;
      t10.disabled = lock;
    }

    function setDurationMinutes(min){
      intervalMin = clampInt(min, 2, 10);
      state.durationMin = intervalMin;
      durationMs = intervalMin * 60 * 1000;
      intervalLabel.textContent = `${intervalMin} min`;
      if (!running) timeEl.textContent = fmtMMSS(durationMs);
      saveState();

      t2.classList.toggle("primary", intervalMin === 2);
      t5.classList.toggle("primary", intervalMin === 5);
      t10.classList.toggle("primary", intervalMin === 10);

      setToast(`Time set to ${intervalMin} minutes.`);
    }

    function buildModeChecks(){
      modeChecks.innerHTML = "";
      for (const k of MODE_KEYS){
        const id = "cb_" + cssKey(k);
        const dotColor = (k === "Group 1") ? "#1e5aa8" : (k === "Group 2") ? "#f08a1a" : "#2e7d32";
        const checked = state.enabled[k] ? "checked" : "";
        const wrap = document.createElement("div");
        wrap.className = "chip";
        wrap.innerHTML = `
          <label>
            <input type="checkbox" id="${id}" ${checked}>
            <span class="dot" style="background:${dotColor}"></span>
            <span><b>${k}</b></span>
          </label>
        `;
        modeChecks.appendChild(wrap);

        el(id).onchange = () => {
          state.enabled[k] = el(id).checked;
          saveState();
          if (!running) refreshIdleView();
        };
      }
    }

    function refreshIdleView(){
      const rot = buildRotation();
      if (rot.length === 0){
        badge.textContent = "IDLE";
        modeEl.textContent = "Select groups";
        timeEl.textContent = "--:--";
        nextEl.textContent = "NEXT UP: --";
        subEl.textContent = "Pick at least one group.";
        setBlink(false);
        resetCar();
        stage.style.background = "rgba(0,0,0,.15)";
        startBtn.disabled = true;
        return;
      }

      startBtn.disabled = false;

      const firstKey = rot[0];
      const nextKey = (rot.length === 1) ? firstKey : rot[1];

      badge.textContent = "IDLE";
      modeEl.textContent = firstKey;
      timeEl.textContent = fmtMMSS(durationMs);
      nextEl.textContent = `NEXT UP: ${nextKey}`;
      subEl.textContent = `${intervalMin} min slot`;

      applyStageTheme(firstKey);
      setBlink(false);
      resetCar();
    }

    function clearCountdown(){
      if (countdownTimer){
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
    }

    async function startSlot(){
      const currentKey = rotation[idx];
      const nextKey = getNextKey();

      applyStageTheme(currentKey);

      badge.textContent = "RUNNING";
      statusEl.textContent = `Running: ${currentKey}`;

      modeEl.textContent = currentKey;
      nextEl.textContent = `NEXT UP: ${nextKey}`;
      subEl.textContent = `${intervalMin} min slot`;

      resetCar();
      startCarEffects();

      warned60 = false;
      warned10 = false;
      clearCountdown();
      setBlink(false);

      // Tala slot-start utan krock: Group + duration, i kö
      await speakQueued(`${currentKey}. ${intervalMin} minutes.`);
      beginHeatTimer();
    }

    function beginHeatTimer(){
      slotStartedAt = Date.now();
      slotEndsAt = slotStartedAt + durationMs;
      tick();
      tickTimer = setInterval(tick, 80);
    }

    async function speakCountdown10(){
      // 10..1 i kö, så det inte krockar
      for (let n = 10; n >= 1; n--){
        if (!running) return;
        await speakQueued(String(n));
      }
    }

    function tick(){
      const now = Date.now();
      const remaining = slotEndsAt - now;

      timeEl.textContent = fmtMMSS(remaining);
      setCarProgress(now);

      if (remaining > 0){
        // 1-minut varning + GET READY
        if (!warned60 && remaining <= 60*1000){
          warned60 = true;
          const nextKey = getNextKey();
          badge.textContent = "GET READY";
          subEl.textContent = "1 minute remaining";
          setBlink(true);
          // Kör voice i bakgrunden via queue (utan att stoppa tick)
          speakQueued(`One minute left. Next up: ${nextKey}. Get ready.`);
        }

        // 10 sek kvar: röst-countdown (10..1)
        if (!warned10 && remaining <= 10*1000){
          warned10 = true;
          // starta countdown en gång
          speakQueued("Ten seconds");
          // om du vill ha riktiga 10..1:
          speakCountdown10();
        }
      }

      if (remaining <= 0) endSlot();
    }

    async function endSlot(){
      if (tickTimer){
        clearInterval(tickTimer);
        tickTimer = null;
      }
      clearCountdown();
      setBlink(false);

      carEl.style.left = "100%";
      stopCarEffects();

      const currentKey = rotation[idx];
      await speakQueued(`${currentKey} training end`);

      idx = (idx + 1) % rotation.length;
      startSlot();
    }

    function start(){
      const rot = buildRotation();
      if (rot.length === 0){
        setToast("Select at least one group.");
        return;
      }

      running = true;
      requestWakeLock();
      enterRunView(true);

      idx = 0;

      startBtn.disabled = true;
      stopBtn.disabled = false;
      lockInputs(true);

      setToast("Started.");
      startSlot();
    }

    function stop(){
      running = false;
      releaseWakeLock();
      enterRunView(false);

      if (tickTimer){
        clearInterval(tickTimer);
        tickTimer = null;
      }
      clearCountdown();
      cancelSpeech();

      badge.textContent = "STOPPED";
      statusEl.textContent = "Stopped";
      setBlink(false);

      stopCarEffects();
      resetCar();

      startBtn.disabled = false;
      stopBtn.disabled = true;
      lockInputs(false);

      setToast("Stopped.");
      refreshIdleView();
    }

    async function skip(){
      if (!running || rotation.length === 0) return;

      if (tickTimer){
        clearInterval(tickTimer);
        tickTimer = null;
      }
      clearCountdown();
      setBlink(false);

      carEl.style.left = "100%";
      stopCarEffects();

      const currentKey = rotation[idx];
      await speakQueued(`${currentKey} training end`);

      idx = (idx + 1) % rotation.length;
      startSlot();
    }

    function hideSplash(){
      splash.classList.add("hide");
      setTimeout(() => { splash.style.display = "none"; }, 450);
    }

    enterBtn.onclick = async () => {
      cancelSpeech();
      await speakQueued("Voice enabled");
      hideSplash();
    };

    // Events
    startBtn.onclick = start;
    stopBtn.onclick = stop;
    stopRunBtn.onclick = stop;
    skipRunBtn.onclick = skip;

    t2.onclick = () => setDurationMinutes(2);
    t5.onclick = () => setDurationMinutes(5);
    t10.onclick = () => setDurationMinutes(10);

    // Init
    buildModeChecks();
    setDurationMinutes(state.durationMin || 5);
    refreshIdleView();
  </script>
</body>
</html>
